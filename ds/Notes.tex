\documentclass[12pt]{article}
\usepackage{lscape}
\usepackage{url}
\usepackage{color}
\usepackage{times}
\makeindex

\begin{document}
\title{Revision of EMEP deposition modules}
\author{Dave Simpson}
\maketitle



\section{Introduction}

The deposition code which was constructed prior to 2004 was designed to process
meteorological data as available for the EMEP model's
50x50 km$^2$ grid-squares. A number of steps were needed in order to
get from this `raw' data to meteorological data as required over a
specific landuse class for the deposition code. These processing steps
complicated the original code and do not allow for an easy use of
the same code for other users, for example with real meteorological
data from a field-site.

The code is therefore being re-written in order to generate a more
modular system which can be used both within the EMEP model and 
by external users.
This re-coding is being done in several steps, building up first the
base-modules which later code will require: 


\begin{description}
\item[Step 1] Gst\_ml module\\

- embodies the calculation of the
environmental factors (f\_T, f\_light, etc.) and calculates  g\_stomatal
and g\_sun. A test-driver code \url{Test_Gsto} sets values of T, PAR, etc.
and calls Gsto\_ml.

\item[Step 2]  Radiation\_ml\\

- calculates radiation terms, from zenith angle to PAR. Output example gives
changes in g\_sto and g\_sun over one day.

\item[Step 3]  Rsurface\_ml + Rb\_ml

- calculates Rsur for wet and dry surfaces, as well as Rb. Now the call to g\_stomatal is
from within the Rsurface subroutine.

\item[Step 4]  Read in hourly NWP met data and convert to local meteorology
\dots to be done \dots
\end{description}

\vspace{1cm}

With each step there is a
test-driver to allow the code to be run with simple inputs. For example,
\url{Test_Gsto.f90} sets some values of temperature, humidity, LAI, etc. 
and calls \url{Gsto_ml}. \url{Test_Rad.f90} calls the radiation routines
every hour over a day to calculate g\_sto and g\_sun.


\section{Code structure}

Modern Fortran stresses the use of modules for storing data and for keeping related-subroutines
together. I have therefore attempted to structure the new code around a few
modules - keeping separate themes in the different modules.  
For example, all parameters needed to calculated f\_temp, f\_swp, etc. are
essential to the  g\_stomatal calculation, and so the module Gsto\_ml
contains subroutines to read the parameters need for the $f$-factors, and
to calculate these. This module makes no assumptions about phenology
or vegetation characteristics - these are left for the user to specify.

\vspace{1cm}

A few modules serve as the basis of the new code. One module in
particular, \url{LocalVariables_ml} is designed simply as a container
of data relavent to the local landuse, and  which can be used by  other
modules in many ways. In fortran'90, any routines which has
\url{use LocalVariables_ml} can read and/or change the LAI values stored
in this module. 

This organisation means that the user can choose how to set local
variables in many ways. For example, the EMEP model might have many steps
to get from NWP data to local values of $u_*$, whereas another user
has  measured values which can be used directly.  The code makes no
assumptions in the first instance about where local $u_*$ values come from.

Further, we do not pass specific meteorological variables through
subroutine arguments, but rather just `use' \url{LocalVariables_ml}.
This allows use to call say \url{Rsurface_ml} with very few
arguments (probably just land-use code and debug-flags, as well
as outputs Rsur, Rb), so that
there is no restriction forced on the meteorological data which
\url{Rsurface_ml} can use. As long as the data is contained in
\url{LocalVariables_ml} it can  be used or neglected at will.



\section{Modules}


The following sections give more details on each module, and list the
`public' routines and variables.  Modules are listed loosely in order from
the simple base modules to the more complex modules which depend on
these.



\subsection{LocalVariables\_ml}

--  stores meteorology and local vegetation characteristics for a specific land-cover.
  For example, Ts\_C, $u_*$, RH, h, LAI  are stored here.
  The local values of PARsun, PARshade and LAIsunfrac are also stored here
  since these vary with landuse LAI and albedo.

\begin{footnotesize}
\begin{verbatim}
   real, public, save ::  &
        Ts_C         &      ! Surface temperature in degrees C
       ,psurf        &      ! Surface pressure, Pa
       ,precip       &      ! Precipitation at ground, mm/hr
       ,wetarea      &      ! Area (fraction) of grid square assumed wet
       ,rh           &      ! Relative humidity, fraction (0-1)
       ,vpd          &      ! Vapour pressure deficit  (kPa) ! CHECK UNITS
       ,swp          &      ! Vapour pressure deficit  (kPa) ! CHECK UNITS
       ,cl           &      ! Cloud-cover
!
! Micro-met
       ,ustar        &      ! friction velocity, m/s
       ,invL         &      ! 1/L, where L is Obukhiov length (1/m)
! Vegetation
       ,LAI          &      ! Leaf area index (m2/m2)
       ,SAI          &      ! Surface area index (m2/m2)
       ,hveg         &      ! Height of veg.      (m)
       ,d            &      ! displacement height (m)
       ,z0           &      ! roughness length    (m)
!
! Radiation
       ,PARsun       &      ! photosynthetic active radn. for sun-leaves
       ,PARshade     &      !  " " for shade leaves
       ,LAIsunfrac          ! fraction of LAI in sun
! Chemistry
       ,so2nh3ratio         !  for CEH deposition scheme

   logical, public, save :: &
       is_wet              !  true if precip > 0
\end{verbatim}
\end{footnotesize}


\subsection{LandClasses\_ml}

--  defines the number of possible land-classes (NLANDUSE), and gives some
  basic codes and characteristics - for example if the landuse is forest,
  crop, or water. Landuse-associated datafiles needed by other
  modules must contain the same number of land-classes and use the same 
  landuse-code. (A user will usually work with just one of the defined
  land-use classes - there is no requirement to use all.)

\begin{footnotesize}
\begin{verbatim}
type, public :: land_class
   character(len=3)  :: code
    character(len=13) :: name
    logical           :: Gcalc   ! calculate Gsto?  Set F for bulk Rs
    logical           :: forest  !
    logical           :: crops   !
    logical           :: water   !
    real              :: b       ! in-canopy resistance factor
    real              :: albedo  ! fraction
    real              :: RgsS    !
    real              :: RgsO    !
 end type land_class

 type(land_class), public, dimension(NLANDUSE) :: landuse
\end{verbatim}
\end{footnotesize}


\subsection{My\_DryDrep\_ml}

  -- specifies the gases to be used, and the relation to the
Wesely indices. Here we just set for ozone, using:

\begin{footnotesize}
\begin{verbatim}
  integer, public, parameter :: NDRYDEP_CALC = 1

  integer, public, parameter, dimension(NDRYDEP_CALC) :: &
       DRYDEP_CALC = (/ WES_O3 /)
\end{verbatim}
\end{footnotesize}



\subsection{Io\_ml}

-- provides some routines to check, open and close files. Ensures
   that all required input files are actually present, and simplifies
   reading files where the first few lines (headers) should be skipped.


\begin{footnotesize}
\begin{verbatim}
  public :: check_file   !  checks that file exists and stops if required
  public :: open_readfile    !  checks that file exists and opens if required
  public :: wordsplit    !  Splits input text into words
 
  logical, public :: fexist                      ! true if file exists
  integer, public, parameter :: NO_FILE = 777    ! code for non-existing file
  integer, public, save :: ios                   ! i/o error status number
  character(len=120), public :: io_msg           ! i/o error message
\end{verbatim}
\end{footnotesize}


\subsection{Radiation\_ml}

-- provides essential radiation terms and
consists of a number of routines to calculate these.

From the code:
\begin{footnotesize}
\begin{verbatim}
  !/ Subroutines:
  public :: ZenAng         ! => coszen=cos(zen), zen=zenith angle (degrees)
  public :: ClearSkyRadn   ! => irradiance (W/m2), clear-sky
  public :: CloudAtten     ! => Cloud-Attenuation factor
  public :: CanopyPAR      ! => sun & shade PAR  values, and LAIsunfrac

  !/ Functions:
  public :: daytime        ! true if zen < 89.9 deg


  real, public, save :: solar       ! => irradiance (W/m^2)
  real, public, save :: Idrctn      ! => irradiance (W/m^2), normal to beam
  real, public, save :: Idfuse      ! => diffuse solar radiation (W/m^2)
  real, public, save :: Idrctt      ! => total direct solar radiation (W/m^2)

  real, public, save :: zen         !   Zenith angle (degrees)
  real, public, save :: coszen      ! = cos(zen)
\end{verbatim}
\end{footnotesize}


\subsection{Gsto\_ml}

-- Conatins the data and routines needed to calculate stomatal conductance:
\begin{footnotesize}
\begin{verbatim}
  !/--------- Subroutines --------------------------------------------------

  public :: Init_gsto       !- Reads in f-factors, Initialises
  public :: g_stomatal      !- produces g_sto and g_sun

  !/--------- Variables available from this module -----------------------

  real, public, save  :: &
          g_sto          & ! stomatal conductance (m/s)
       ,  g_sun            ! g_sto for upper-canopy sun-leaves


  real, public, save :: & !/ g_sto factors (0-1):
        f_phen     &            ! phenology (age)
       ,f_temp     &            ! temperature
       ,f_vpd      &            ! vapour pressure deficit
       ,f_light    &            ! light
       ,f_swp                   ! soil water potential
\end{verbatim}
\end{footnotesize}


Also, for each landuse we set the various parameters, e.g.:
\begin{footnotesize}
\begin{verbatim}
type(gf), private, parameter, dimension(NLANDUSE) :: g =(/ &
! g_sto  variables read previously from Gsto_inputs.dat   ................
!------------------------------------------------------------------------------
!   LU     gmax  fmin flight     ftemp   fphe Sfphen Efphen   fVDP          fSWP
!                            min opt max min  len   len   max    min    SWPmax  PWP
!------------------------------------------------------------------------------
 gf("CF ",160,  0.1  ,0.0083,  1,18,36,  0.2, 130, 130,  0.6  , 3.3,  -0.76, -1.2   ) &
,gf("DF ", .....
\end{verbatim}
\end{footnotesize}


\subsection{CEH\_ml}

 --- For other gases than ozone. Ignore for now.

\subsection{Rb\_ml}

Straightfoward - calculates Rb



\subsection{Rsurface\_ml}

--  Calculates \url{Rsur_dry} and \url{Rsur_wet} for all gases specified in
\url{My_DryDep_ml}. 

From the code:
\begin{footnotesize}
\begin{verbatim}
public   ::  Rsurface

  subroutine Rsurface(lu,debug_flag,Rsur_dry,Rsur_wet,errmsg) 

! Output:

  ! bulk canopy surface resistances (s/m):
   real,dimension(:),intent(out) :: Rsur_dry   !  Rs  for dry surfaces 
   real,dimension(:),intent(out) :: Rsur_wet   !  Rs  for wet surfaces
   character(len=*), intent(out) :: errmsg
\end{verbatim}
\end{footnotesize}


\subsection{Makefiles}

I have made small Makefiles for each step also. Thus, to run \url{Test_Rsur}
I would do:

\begin{verbatim}
    cp Makefile.Rsur Makefile
    make 
    Test_Rsur
\end{verbatim}


\section{Step2 vs. Step1}

As well as the \url{Radiation_ml}, changes were made to \url{Gsto_ml} 
(to use \url{Io_ml}).

\section{Step3 vs. Step2}

New modules \url{Wesely_ml}, \url{CEH_ml}, \url{My_DryDep_mk}, \url{Rb_ml}
and \url{Rsurface_ml}.

 
\section{F90 vs. F Language}


All code is written for the F compiler, allowing it to run under any f90/f95 system.

\vspace{0.5cm}

F90 is a huge language, which is backwardly compatible with Fortran-77, Fortran-IV
and presumably Fortran-I from the 1950s. This need to keep things compatable means
that code can be written in a very large number of ways - this can be
confusing!


F is a new teaching language which is a pure subset of F90. This means that anything
that compiles with F will compile with any F90 compiler. The reverse is not true - far from it!
F uses only modern coding practices, and is very strict in this. Sometimes the
strictness is annoying, e.g. one has to write \url{read(unit=10,fmt=*)} instead
of just \url{read(10,*)} as F90 would allow. \url{open} statements are even more wordy in F. On the
other hand, some things enforced by F help any code. For example, all variables
have to be declared, and all subroutine arguments defined as \url{intent(in), intent(out) or intent(inout)}. 
\vspace{0.3cm}


A free F compiler can be obtained at \url{www.fortran.com}.
\vspace{0.3cm}

A free F90 compiler can 
be obtained at \url{www.intel.com/software/products/compilers/}.
This free for non-commercial use anyway. I am not sure
if the Windows version is equally free - I use the Linux version.
Intel also has a good debugger idb which is useful, although not perfect
for F90.


\end{document}

